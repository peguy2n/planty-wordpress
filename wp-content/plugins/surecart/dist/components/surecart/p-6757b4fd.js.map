{"version":3,"names":["productViewed","product","event","CustomEvent","detail","id","name","permalink","prices","bubbles","document","dispatchEvent","availablePrices","productId","_a","state","filter","price","archived","sort","a","b","position","getProduct","isStockNeedsToBeChecked","_b","_c","_d","stock_enabled","allow_out_of_stock_purchases","isOptionSoldOut","optionNumber","option","isProductVariantOptionSoldOut","variantValues","isOptionMissing","isProductVariantOptionMissing","isProductOutOfStock","selectedVariant","available_stock","isSelectedVariantMissing","variants","length","getVariantFromValues","values","undefined","getDefaultState","serializedProductState","getSerializedState","Object","reduce","acc","productState","selectedPrice","current","quantity","total","dialog","busy","error","adHocAmount","amount","disabled","line_item","price_id","ad_hoc","ad_hoc_amount","option_1","option_2","option_3","availableSubscriptionPrices","recurring_interval","availableNonSubscriptionPrices","defaultState","stateProduct","isProductPage","forEach","store","createStore","newValue","oldValue","JSON","stringify","onChange","on","dispose","forceUpdate","setProduct","updateSelectedVariant","handleStockWithSelectedVariant","wp","i18n","sprintf","__","updateSelectedPrice","setLineItem"],"sources":["./src/store/product/events.ts","./src/store/product/getters.ts","./src/store/product/store.ts","./src/store/product/setters.ts","./src/store/product/watchers.ts"],"sourcesContent":["import { Product } from 'src/types';\n\n/**\n * Product viewed event.\n */\nexport const productViewed = (product: Product) => {\n  const event = new CustomEvent('scProductViewed', {\n    detail: {\n      id: product?.id,\n      name: product?.name,\n      permalink: product?.permalink,\n      prices: product?.prices,\n    },\n    bubbles: true,\n  });\n  document.dispatchEvent(event);\n};\n","import { Price, ProductState } from 'src/types';\n\n/**\n * Internal dependencies.\n */\nimport state from './store';\nimport { getSerializedState, isProductVariantOptionMissing, isProductVariantOptionSoldOut } from '@store/utils';\nimport { getVariantFromValues } from '../../functions/util';\n\n/**\n * Available product prices\n *\n * @param {string} productId - Product ID\n *\n * @returns {Price[]} - Returns an array of prices that are not archived\n */\nexport const availablePrices = (productId: string): Price[] => (state[productId]?.prices || []).filter(price => !price?.archived).sort((a, b) => a?.position - b?.position); // sort by position\n\n/**\n * Get Product\n */\nexport const getProduct = (productId?: string): ProductState => state[productId] ?? null;\n\n/**\n * Check if product label stock is enabled and not out of stock purchases are allowed.\n *\n * @returns {boolean} - Returns stock needs to be checked or not\n */\nexport const isStockNeedsToBeChecked = (productId: string) => !!(state?.[productId]?.product?.stock_enabled && !state?.[productId]?.product?.allow_out_of_stock_purchases);\n\n/**\n * Check if this option is out of stock base on the selected variant.\n */\nexport const isOptionSoldOut = (productId: string, optionNumber: number, option: string) =>\n  isProductVariantOptionSoldOut(optionNumber, option, state[productId].variantValues, state[productId].product);\n\n/**\n * Check if this option is out of stock base on the selected variant.\n */\nexport const isOptionMissing = (productId: string, optionNumber: number, option: string) =>\n  isProductVariantOptionMissing(optionNumber, option, state[productId].variantValues, state[productId].product);\n\n/**\n * Is product out of stock.\n *\n * @returns {boolean} - Returns true if product is out of stock\n */\nexport const isProductOutOfStock = (productId: string) => {\n  // If stock doesn't need to be checked, product is not out of stock.\n  if (!isStockNeedsToBeChecked(productId)) {\n    return false;\n  }\n\n  // If no variant is selected, check against product stock.\n  if (!state?.[productId]?.selectedVariant?.id) return state[productId].product?.available_stock <= 0;\n\n  // Check against selected variant's stock.\n  return state[productId].selectedVariant?.available_stock <= 0;\n};\n\n/**\n * Is the selected variant missing.\n */\nexport const isSelectedVariantMissing = (productId: string) =>\n  !!state?.[productId]?.variants?.length && getVariantFromValues({ variants: state[productId].variants, values: state[productId].variantValues })?.id === undefined;\n\n/**\n * Get product default state\n *\n * @returns {ProductState} - Returns the product state\n */\nexport const getDefaultState = (): { [key: string]: ProductState } => {\n  const { product: serializedProductState = {} } = getSerializedState();\n\n  return (\n    Object.values(serializedProductState as { [key: string]: ProductState }).reduce((acc, productState) => {\n      const { selectedPrice, product, selectedVariant } = productState || {};\n      const current: ProductState = {\n        ...productState,\n        quantity: 1,\n        total: null,\n        dialog: null,\n        busy: false,\n        error: null,\n        adHocAmount: selectedPrice?.amount || null,\n        disabled: selectedPrice?.archived || product?.archived,\n        line_item: {\n          price_id: selectedPrice?.id,\n          quantity: 1,\n          ...(selectedPrice?.ad_hoc ? { ad_hoc_amount: selectedPrice?.amount } : {}),\n        },\n        variantValues: {\n          ...(selectedVariant?.option_1 ? { option_1: selectedVariant?.option_1 } : {}),\n          ...(selectedVariant?.option_2 ? { option_2: selectedVariant?.option_2 } : {}),\n          ...(selectedVariant?.option_3 ? { option_3: selectedVariant?.option_3 } : {}),\n        },\n      };\n\n      acc[product.id] = current;\n\n      return acc;\n    }, {}) || {}\n  );\n};\n\nexport const availableSubscriptionPrices = (productId: string) =>\n  (availablePrices(productId) || []).filter(price => price?.recurring_interval).sort((a, b) => a?.position - b?.position);\n\nexport const availableNonSubscriptionPrices = (productId: string) =>\n  (availablePrices(productId) || []).filter(price => !price?.recurring_interval).sort((a, b) => a?.position - b?.position);\n","import { createStore } from '@stencil/store';\nimport { ProductState } from 'src/types';\nimport { productViewed } from './events';\nimport { getDefaultState } from './getters';\n\ninterface Store {\n  [key: string]: ProductState;\n}\n\nconst defaultState: Store = getDefaultState();\n\nObject.values(defaultState)\n  .filter((stateProduct: ProductState) => stateProduct?.isProductPage)\n  .forEach((stateProduct: ProductState) => {\n    if (stateProduct?.product?.id) {\n      productViewed(stateProduct?.product);\n    }\n  });\n\nconst store = createStore<Store>(defaultState, (newValue, oldValue) => {\n  return JSON.stringify(newValue) !== JSON.stringify(oldValue);\n});\n\nconst { state, onChange, on, dispose, forceUpdate } = store;\nexport default state;\nexport { state, onChange, on, dispose, forceUpdate };\n","import { ProductState } from 'src/types';\nimport state from './store';\n\n/**\n * Set the product\n *\n * @param {string} productId - Product ID\n * @param {Partial<ProductState>} product - Product object\n *\n * @returns {void}\n */\nexport const setProduct = (productId: string, product: Partial<ProductState>): void => {\n  if (!productId) return;\n  state[productId] = {\n    ...state[productId],\n    ...product,\n  };\n};\n","import { ProductState } from 'src/types';\nimport state, { on } from './store';\nimport { setProduct } from './setters';\nimport { getVariantFromValues } from '../../functions/util';\nimport { isStockNeedsToBeChecked } from './getters';\nimport { speak } from '@wordpress/a11y';\nimport { __, sprintf } from '@wordpress/i18n';\n\n/** Handle set event on products store. */\non('set', (productId: string, newValue: ProductState, oldValue: ProductState) => {\n  if (newValue?.selectedPrice?.id !== oldValue?.selectedPrice?.id) {\n    updateSelectedPrice(productId, newValue);\n  }\n\n  // if variants change, check the stock.\n  if (newValue?.selectedVariant?.id !== oldValue?.selectedVariant?.id) {\n    handleStockWithSelectedVariant(productId);\n  }\n\n  const shouldUpdateLineItem = !oldValue || ['selectedPrice', 'adHocAmount', 'quantity'].some(key => JSON.stringify(newValue[key]) !== JSON.stringify(oldValue[key]));\n  if (shouldUpdateLineItem) {\n    setLineItem(productId);\n  }\n\n  const shouldUpdateVariants = !oldValue || JSON.stringify(newValue?.variantValues) !== JSON.stringify(oldValue?.variantValues);\n  if (shouldUpdateVariants) {\n    updateSelectedVariant(productId, newValue);\n  }\n});\n\n/**\n * Update the selected variant based on chosen values.\n */\nconst updateSelectedVariant = (productId: string, newValue: ProductState) => {\n  const matchedVariant = getVariantFromValues({ variants: state[productId].variants, values: newValue?.variantValues });\n\n  if (matchedVariant) {\n    setProduct(productId, { selectedVariant: matchedVariant });\n  }\n};\n\n/**\n * Handle when the selected variant changes.\n */\nconst handleStockWithSelectedVariant = (productId: string) => {\n  // make sure we have a selected variant and stock needs to be checked.\n  if (!state[productId].selectedVariant || !isStockNeedsToBeChecked) {\n    return;\n  }\n\n  // if available stock is less than the quantity, adjust the quantity to the max available.\n  if (state[productId]?.selectedVariant.available_stock < state[productId]?.quantity) {\n    state[productId].quantity = state[productId]?.selectedVariant.available_stock || 1;\n    speak(\n      sprintf(__('There are just %d items left in stock, and the quantity has been adjusted to %d.', 'surecart'), state[productId].quantity, state[productId].quantity),\n      'assertive',\n    );\n  }\n};\n\nconst updateSelectedPrice = (productId: string, newValue: ProductState) => {\n  setProduct(productId, {\n    // update the total when the selected price changes.\n    total: state[productId].adHocAmount || newValue?.selectedPrice?.amount || 0,\n    // set the ad hoc amount to the selected product amount.\n    adHocAmount: newValue?.selectedPrice?.amount,\n    // update disabled based on if price is archived or product is archived.\n    disabled: newValue?.selectedPrice?.archived || state[productId].product?.archived,\n  });\n};\n\nconst setLineItem = (productId: string) => {\n  setProduct(productId, {\n    line_item: {\n      price_id: state[productId]?.selectedPrice?.id,\n      quantity: state[productId]?.selectedPrice?.ad_hoc ? 1 : state[productId].quantity,\n      ...(state[productId]?.selectedPrice?.ad_hoc ? { ad_hoc_amount: state[productId]?.adHocAmount } : {}),\n      variant: state[productId].selectedVariant?.id,\n    },\n  });\n};\n"],"mappings":"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"}